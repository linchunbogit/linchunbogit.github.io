---
layout:     post
title:      "c++指针和引用"
subtitle:   " "
date:       2018-05-06 19:43:00
author:     "Popo"
header-img: "img/bg/bg_xingkong5.jpg"
tags:
	- c++
    - 编程基础
---

### 指针
指针是一个特殊的变量，它里面存储的数值被解释成内存里的一个地址。

##### 指针类型
从语法的角度看，只要把指针声明语句里的指针的名字去掉，剩下的部分就是这个指针的类型。

```
// 指针的类型是int *
// 一个指向int类型的指针
int *ptr;

// 指针的类型int *[3]
// 指针数组，3个指向int类型指针
int *ptr[3];

// 指针的类型是int (*)[3]
// 数组指针，一个指向int[3]数组的指针
int (*ptr)[3];

// 指针的类型是int **
// 指针的指针，一个指向指针的指针
// 意义与指针数组一样，单指针指向的数组长度是不固定的
int **ptr;

// 指针的类型是int*(*)[4]
// 数组指针的指针，一个指向4个都想int类型数组的指针
int *(*ptr)[4];

// 函数指针
// 一个指向返回int类型且带一个参数int的函数的指针
int (*p)(int);
```

##### 指针和数组
```
// []优先级比*高
实参                                        所匹配的形参
数组的数组            char c[8][10];            数组指针            char (*)[10];
指针数组            char *c[10];             指针的指针            char **c;
数组指针(行指针)    char (*c)[10];            不改变            char (*c)[10];
指针的指针            char **c;                 不改变            char **c;
```

##### 智能指针分类
* auto_ptr：所有权独占，不能共享，但是可以转移
* share_ptr：所有权共享，内部维护了一个引用计数，+1, -1
* weak_ptr：弱指针，它要与shared_ptr配合使用，循环引用 不+-1
* scoped_ptr：与auto_ptr类似，所有权独占，不能共享，但是也不可以转移

##### 函数指针
```
返回类型 (*函数名)(参数...)

// 定义
int (*comp)(void*, void*)

// 使用
(*comp)(&a, &b);

// 注意,下面定义是函数而不是函数指针
int *comp(void *, void *)
```

##### void指针
```
int main()
{
    char str;
    void *voidc = &str;

    *((char*)voidc) = 'a';

    cout << *((char*)voidc) << endl;

    return 0;
}
```

##### const指针
* const在*左边，表示不能更改指针所指向的内容
```
int a = 10;
int b = 20;
const int *p;
p = &a;
*p = 200;    // 这是错误的
p = &b;        // 这是正确的
```

* const在*右边，表示指针为常量，表示指针不能指向别的内容
```
int a = 10;
int b = 20;
int * const p;
p = &a;
*p = 200;    // 这是正确的
p = &b;        // 这是错误的
```

##### 野指针
已经delete的指针还在使用，这种就是所谓“野指针”，即指针没有指向一个活着的对象。
```
class A{
public:
    int item;
    A():item(1){};
};

void f(){
    A *p=new A();
    delete p;
    cout<<p->item<<endl;  //程序奔溃
}
```

##### 强指针和弱指针
强指针与一般意义的智能指针概念相同，通过引用计数来记录有多少使用者在使用一个对象，如果所有使用者都放弃了对该对象的引用，则该对象将被自动销毁。
弱指针也指向一个对象，但是弱指针仅仅记录该对象的地址，不能通过弱指针来访问该对象，也就是说不能通过弱智真来调用对象的成员函数或访问对象的成员变量。
对于两个强指针对象A和B，A引用了B，B又引用了A，当你去析构A的时候，B的计数减1，然后它试图析构自己，而B析构的时候，需要先去析构A。这样就造成了循环依赖。为了解决这一问题，我们引入了弱指针的概念，定义两个强指针不能循环引用，一旦循环引用，那么必须一个是强，一个是弱，或者两个都是弱。弱指针也是针对一个对象而言的，一旦这个对象的强指针引用为0，那么无论弱指针是否为0，该对象会被析构。所以，此时一个对象就有了两个计数，强指针计数和弱指针计数。
由于弱引用肯定会大于等于强引用，所以当弱引用为0时，强应用计数要么为INITIAL_STRONG_VALUE，要么为0。第一种情况下，使用弱引用来delete对象，第二种情况下，使用强引用来delete对象。
在使用弱指针的时候，由于可能此时已经被析构，需要先检查一下是否被析构，这个通过弱指针升级为强指针来做。弱指针也指向一个对象，但是弱指针仅仅记录该对象的地址，不能通过弱指针来访问该对象，也就是说不能通过弱智真来调用对象的成员函数或访问对象的成员变量。要想访问弱指针所指向的对象，需首先将弱指针升级为强指针。弱指针所指向的对象是有可能在其它地方被销毁的，如果对象已经被销毁，转换为强指针时将返回空指针，这样就能避免出现地址访问错的情况。

### 引用
* 引用不是变量
* 引用仅仅是变量的别名
* 引用没有自己的独立空间
* 引用要与它所引用的变量共享空间
* 对引用所做的改变实际上是对它所引用的变量的改变
* 引用在定义的时候要进行初始化
* 引用一经初始化，不能重新指向其它变量

```
int main(void)
{
    int val = 100;

    // int& refval;        // Error，引用必须初始化

    int& refval = val;
    refval = 200;        // 将200赋值给refval，实际上改变得是val这个变量
    cout<<"val="<<val<< endl;     // 200

    int val2 = 500;
    refval = val2;                // 不代表将refval引用至val2这个变量，而是将val2赋值给refval
    cout<<"val="<<val<< endl;     // 500
}
```

##### const引用
const引用指向const对象的引用
```
int main(void)
{
    const int val = 1024;
    const int& refval = val;

    // int& ref2 = val;            // Error, 非const引用不可以指向const对象

    // refval = 200;            // Error,refval是一个常量

    int val2 = 1024;
    const int& ref3 = val2;        // warn，const引用指向非const对象

    double val3 = 3.14;
    const int& ref4 = val3;        // int tmp = val3;
                                // const int& ref4 = tmp;
    cout<<"ref4="<<ref4<<endl;    // 3
    cout<<"ref3="<<val3<<endl;    // 3.14

    // int& ref5 = val3;        // Error, 这里不会有int tmp = val3;
                                //                     int& ref5 = tmp;
}
```

##### 引用传递
在函数调用的时候，引用被初始化
```
void swap(int& a, int& b)
{
    int tmp = a;
    a = b;
    b = tmp;
}

int main(void)
{
    int a = 5;
    int b = 6;

    swap(a, b);        // 引用被初始化 a=a, b=b,

    cout<<"a="<<a<<endl;
    cout<<"b="<<b<<endl;
}
```

##### 引用作为函数返回值
引用在函数返回的时候初始化
不能返回对局部变量的引用

```
int a[] = {0, 1, 2, 3, 4};

int& index(int i)
{
    return a[i];
}

int& add(int a, int b)
{
    int sum ;
    sum = a + b;

    return sum;
}

int main(void)
{
    index(3) = 100;                    // 引用作为函数返回值，使得函数可以放在赋值运算符左边
                                    // 函数返回引用，引用在函数返回的时候初始化
                                    // index(3)在函数返回的时候被初始化为a[3]
    cout<<"a[3]="<<a[3]<<endl;        // 100

    int n = add(3, 4);
    int& n2 = add(5, 6);            // n2是引用，没有自己独立空间
                                    // n2的值依赖它所引用的变量
                                    // 如果n2所引用的变量的生命期结束了，也就是说n2是一个无效的引用，那么n2的值将是不确定的

    cout<<"n2="<<n2<<endlf;            // 11,这里正常，是因为内容对应的空间还没有别其它内容覆盖
    cout<<"n="<<n<<endl;            // 7
    cout<<"n2="<<n2<<endl;            // 不确定
}
```

### 区别
* 引用访问一个变量时直接访问，而指针是间接访问
* 引用是一个变量的别名，本身不单独分配自己的内存空间，而指针有自己的内存空间，指针的本质是一个变量
* 引用一经初始化不能再引用其它变量，而指针可以（除了const指针）



