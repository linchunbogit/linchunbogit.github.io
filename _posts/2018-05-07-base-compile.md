---
layout:     post
title:      "编译原理"
subtitle:   " "
date:       2018-05-07 11:14:00
author:     "Popo"
header-img: "img/bg/bg_xingkong5.jpg"
tags:
    - 编程基础
---


### 程序的编译过程
编译预处理->编译->优化->汇编->链接

##### 编译预处理(头文件和宏的展开)
* 宏定义指令

\#define MAX_FILE_LENGTH 1024
这些宏指令会被替换成相应的定义的内容

* 条件编译指令

\#if \#ifdef \#ifndef \#else \#elif \#endif
这些指令会用于决定编译那些程序段

* 头文件包含指令

\#include "hello.h" \#include <hello.h>
这些文件的声明将会包含到使用include的文件里面

* 特殊符号

\_\_FILE\_\_, \_\_LINE\_\_, \_\_DATE\_\_, \_\_TIME\_\_, \_\_STDC\_\_(编译器是否遵循ANSI C), #, ##
这些特殊符号也会和宏定义指令一样，进行相应的替换或者处理。（#像宏一样替换,## 是做字符拼接用的）

* 预处理模块

预处理工作由#pragma命令完成，#Pragma命令将设定编译器的状态或者是指示编译器完成  一些特定的动作，例如大家经常见到的#program once，或者偶尔见得#program message。


##### 编译(生成汇编程序)
经过预编译得到的输出文件中，将只有常量。如数字、字符串、变量的定义，以及C语言的关键字，如main,if,else,for,while,{,},+,-,*,\，等等。编译程序所要作得工作就是通过词法分析和语法分析等等，将其翻译成等价的中间代码表示或汇编代码。
* __cdecl调用约定：
 1. 参数入栈顺序是从右向左；
 2. 在被调用函数返回后，由调用方调整堆栈。
* __stdcall调用约定：
 1. 参数从右向左压入堆栈
 2. 函数自身清理堆栈
 3. 函数名自动加前导的下划线，后面紧跟一个@符号，其后紧跟着参数的尺寸
 4. 函数参数个数不可变。
* __fastcall调用约定：
 1. 函数的第一个和第二个参数通过寄存器传递，其他参数通过从右向左的顺序压栈；
 2. 被调用者清理堆栈；
 3. 函数名修改规则同stdcall。
* __thiscall调用约定：
 1. 参数从右向左入栈；
 2. 如果参数个数确定，this指针通过寄存器传递；如果参数个数不确定，this指针最后被压入堆栈；
 3. 对参数个数不定的，调用者清理堆栈，否则函数自己清理堆栈。

##### 优化
优化一部分是对中间代码的优化。这种优化不依赖于具体的计算机。另一种优化则主要针对目标代码的生成而进行的。
* 对于前一种优化，主要的工作是删除公共表达式、循环优化（代码外提、强度削弱、变换循环控制条件、已知量的合并等）、复写传播，以及无用赋值的删除，等等。
* 后一种类型的优化同机器的硬件结构密切相关，最主要的是考虑是如何充分利用机器的各个硬件寄存器存放的有关变量的值，以减少对于内存的访问次数
* 我们在使用gcc/g++编译程序的时候也可以通过-O选项指定优化等级：主要有0,1,2,3和s等5种级别的优化，0表示没有任何优化，但是我们不推荐采用O3和Os级别的优化，因为可能会导致一些不可预期的错误。

##### 汇编(生成可重定位目标文件)
汇编过程实际上指把汇编语言代码翻译成目标机器指令的过程。对于被翻译系统处理的每一个C语言源程序，都将最终经过这一处理而得到相应的目标文件（.o文件）。

##### 链接（将库以及.o文件进行链接生成可执行文件）
由汇编程序生成的目标文件并不能立即就被执行，其中可能还有许多没有解决的问题。例如，某个源文件中的函数可能引用了另一个源文件中定义的某个符号（如变量或者函数调用等）；在程序中可能调用了某个库文件中的函数，等等。所有的这些问题，都需要经链接程序的处理方能得以解决。链接程序的主要工作就是将有关的目标文件彼此相连接，也即将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够被操作系统装入执行的统一整体。根据开发人员指定的同库函数的链接方式的不同，链接处理可分为两种：
1. 静态链接：在这种链接方式下，函数的代码将从其所在地静态链接库中被拷贝到最终的可执行程序中。这样该程序在被执行时这些代码将被装入到该进程的虚拟地址空间中。静态链接库实际上是一个目标文件的集合，其中的每个文件含有库中的一个或者一组相关函数的代码。
2. 动态链接：在此种方式下，函数的代码被放到称作是动态链接库或共享对象的某个目标文件中。链接程序此时所作的只是在最终的可执行程序中记录下共享对象的名字以及其它少量的登记信息。在此可执行文件被执行时，动态链接库的全部内容将被映射到运行时相应进程的虚地址空间。动态链接程序将根据可执行程序中记录的信息找到相应的函数代码。




















